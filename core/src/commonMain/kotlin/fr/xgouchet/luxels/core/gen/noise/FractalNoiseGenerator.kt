package fr.xgouchet.luxels.core.gen.noise

import kotlin.math.pow

/**
 * Provides a noise based on the concept of Fractal noise.
 *
 * It takes several layers of noise generated by a delegate [DimensionalNoiseGenerator],
 * and adds them with different weights for each layer.
 * @param delegate the delegate [DimensionalNoiseGenerator] used to generate each layer (default: [PerlinNoiseGenerator])
 * @param octaves the number of layers (default: 4)
 * @param lacunarity the scale between two successive layers (default: 2)
 * @param persistence the base of the contribution each layer provides (default: 0.5)
 */
class FractalNoiseGenerator(
    private val delegate: DimensionalNoiseGenerator = PerlinNoiseGenerator(),
    private val octaves: Int = 4,
    private val lacunarity: Double = 2.0,
    private val persistence: Double = 0.5,
) : DimensionalNoiseGenerator {

    // region DimensionalNoiseGenerator

    override fun noise(input: List<Double>, outputSize: Int): List<Double> {
        val sum = DoubleArray(outputSize) { 0.0 }
        var scale = 0.0

        for (o in 0..<octaves) {
            val oExp = o.toDouble()
            val frequency = lacunarity.pow(oExp)
            val amplitude = persistence.pow(oExp)

            val scaledInput = input.map { it * frequency }
            delegate.noise(scaledInput, outputSize).forEachIndexed { i, d ->
                sum[i] += d * amplitude
            }
            scale += amplitude
        }

        return sum.toList().map { it / scale }
    }

    // endregion

    companion object {

        /**
         * Create a White Noise generator based on the delegate.
         * Each layer will contribute with the same importance to the final noise.
         *
         * @param delegate the delegate [DimensionalNoiseGenerator] used to generate each layer
         *  @param octaves the number of layers (default: 8)
         */
        fun whiteNoise(
            delegate: DimensionalNoiseGenerator,
            octaves: Int = 8,
        ): DimensionalNoiseGenerator {
            return FractalNoiseGenerator(
                delegate,
                octaves = octaves,
                lacunarity = 2.0,
                persistence = 1.0,
            )
        }

        /**
         * Create a Pink Noise generator based on the delegate.
         * This gives slightly more emphasis to the low frequency layers.
         *
         * @param delegate the delegate [DimensionalNoiseGenerator] used to generate each layer
         *  @param octaves the number of layers (default: 8)
         */
        fun pinkNoise(
            delegate: DimensionalNoiseGenerator,
            octaves: Int = 8,
        ): DimensionalNoiseGenerator {
            return FractalNoiseGenerator(
                delegate,
                octaves = octaves,
                lacunarity = 2.0,
                persistence = 0.666,
            )
        }

        /**
         * Create a Brown Noise generator based on the delegate.
         * This gives much more emphasis to the low frequency layers.
         *
         * @param delegate the delegate [DimensionalNoiseGenerator] used to generate each layer
         *  @param octaves the number of layers (default: 8)
         */
        fun brownNoise(
            delegate: DimensionalNoiseGenerator,
            octaves: Int = 8,
        ): DimensionalNoiseGenerator {
            return FractalNoiseGenerator(
                delegate,
                octaves = octaves,
                lacunarity = 2.0,
                persistence = 0.333,
            )
        }

        /**
         * Create a Blue Noise generator based on the delegate.
         * This gives slightly more emphasis to the high frequency layers.
         *
         * @param delegate the delegate [DimensionalNoiseGenerator] used to generate each layer
         *  @param octaves the number of layers (default: 8)
         */
        fun blueNoise(
            delegate: DimensionalNoiseGenerator,
            octaves: Int = 8,
        ): DimensionalNoiseGenerator {
            return FractalNoiseGenerator(
                delegate,
                octaves = octaves,
                lacunarity = 2.0,
                persistence = 1.5,
            )
        }

        /**
         * Create a Violet Noise generator based on the delegate.
         * This gives much more emphasis to the high frequency layers.
         *
         * @param delegate the delegate [DimensionalNoiseGenerator] used to generate each layer
         *  @param octaves the number of layers (default: 8)
         */
        fun violetNoise(
            delegate: DimensionalNoiseGenerator,
            octaves: Int = 8,
        ): DimensionalNoiseGenerator {
            return FractalNoiseGenerator(
                delegate,
                octaves = octaves,
                lacunarity = 2.0,
                persistence = 2.0,
            )
        }
    }
}
